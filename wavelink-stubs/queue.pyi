import asyncio
from collections import deque
from collections.abc import AsyncIterator, Iterable, Iterator
from typing import Any
from typing_extensions import Self, TypeAlias

from .ext import spotify
from .tracks import Playable

_AnyPlayable: TypeAlias = Playable | spotify.SpotifyTrack

__all__ = ("BaseQueue", "Queue")

class BaseQueue:
    _queue: deque[_AnyPlayable]

    def __init__(self) -> None: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __call__(self, item: _AnyPlayable) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> _AnyPlayable: ...
    def __setitem__(self, index: int, item: _AnyPlayable) -> None: ...
    def __delitem__(self, index: int) -> None: ...
    def __iter__(self) -> Iterator[_AnyPlayable]: ...
    def __reversed__(self) -> Iterator[_AnyPlayable]: ...
    def __contains__(self, item: _AnyPlayable) -> bool: ...
    def __add__(self, other: Iterable[_AnyPlayable]) -> Self: ...
    def __iadd__(self, other: Iterable[_AnyPlayable] | _AnyPlayable) -> Self: ...
    def _get(self) -> _AnyPlayable: ...
    def _drop(self) -> _AnyPlayable: ...
    def _index(self, item: _AnyPlayable) -> int: ...
    def _put(self, item: _AnyPlayable) -> None: ...
    def _insert(self, index: int, item: _AnyPlayable) -> None: ...
    @staticmethod
    def _check_playable(item: _AnyPlayable) -> _AnyPlayable: ...
    @classmethod
    def _check_playable_container(cls, iterable: Iterable[object]) -> list[_AnyPlayable]: ...
    @property
    def count(self) -> int: ...
    @property
    def is_empty(self) -> bool: ...
    def get(self) -> _AnyPlayable: ...
    def pop(self) -> _AnyPlayable: ...
    def find_position(self, item: _AnyPlayable) -> int: ...
    def put(self, item: _AnyPlayable) -> None: ...
    def put_at_index(self, index: int, item: _AnyPlayable) -> None: ...
    def put_at_front(self, item: _AnyPlayable) -> None: ...
    def shuffle(self) -> None: ...
    def extend(self, iterable: Iterable[_AnyPlayable], *, atomic: bool = True) -> None: ...
    def copy(self) -> Self: ...
    def clear(self) -> None: ...

class Queue(BaseQueue):
    history: BaseQueue
    _loop: bool
    _loop_all: bool
    _loaded: _AnyPlayable | None
    _waiters: deque[asyncio.Future[Any]]
    _finished: asyncio.Event

    def __init__(self) -> None: ...
    async def __aiter__(self) -> AsyncIterator[_AnyPlayable]: ...
    def get(self) -> _AnyPlayable: ...
    def _get(self) -> _AnyPlayable: ...
    async def _put(self, item: _AnyPlayable) -> None: ...  # type: ignore [reportIncompatibleMethodOverride] # Known
    def _insert(self, index: int, item: _AnyPlayable) -> None: ...
    def _wakeup_next(self) -> None: ...
    async def get_wait(self) -> _AnyPlayable: ...
    async def put_wait(self, item: _AnyPlayable) -> None: ...
    def put(self, item: _AnyPlayable) -> None: ...
    def reset(self) -> None: ...
    @property
    def loop(self) -> bool: ...
    @loop.setter
    def loop(self, value: bool) -> None: ...
    @property
    def loop_all(self) -> bool: ...
    @loop_all.setter
    def loop_all(self, value: bool) -> None: ...
